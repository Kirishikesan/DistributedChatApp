Index: src/app/election/FastBullyAlgorithm.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package app.election;\r\n\r\nimport app.leaderState.LeaderState;\r\nimport app.response.ServerResponse;\r\nimport app.server.Server;\r\nimport app.server.ServerMessage;\r\nimport app.serversState.ServersState;\r\nimport org.json.simple.JSONArray;\r\nimport org.json.simple.JSONObject;\r\nimport org.json.simple.parser.JSONParser;\r\nimport org.json.simple.parser.ParseException;\r\n\r\nimport java.io.IOException;\r\nimport java.util.*;\r\nimport java.util.concurrent.ConcurrentHashMap;\r\nimport java.util.concurrent.atomic.AtomicInteger;\r\nimport java.util.stream.Collectors;\r\n\r\n\r\npublic class FastBullyAlgorithm implements Runnable{\r\n\r\n    String operation;\r\n\r\n    final int t1 = 10000; // threshold for respond from coordinator\r\n    final int t2 = 20000; // threshold for respond from candidates - answer messages\r\n    final int t3 = 35000; // threshold for respond from win candidate - coordinator messages\r\n    final int t4 = 30000; // threshold for respond from either a nomination or a coordinator\r\n\r\n    static int sourceServerId=-1;\r\n\r\n    static volatile boolean electionStatus = false;\r\n    static volatile boolean answerStatus = false;\r\n    static volatile boolean viewStatus = false;\r\n    static volatile boolean nominationStatus = false;\r\n    static volatile boolean coordinatorStatus = false;\r\n\r\n    public static volatile boolean isLeader = false;\r\n\r\n    static volatile int highestPriorityServerId = -1;\r\n\r\n    static volatile ConcurrentHashMap<Integer, Server> answersMap = new ConcurrentHashMap<>();\r\n    static Set<Integer> incomingViews = Collections.synchronizedSet(new HashSet<>());\r\n\r\n    public FastBullyAlgorithm(String operation) {\r\n        this.operation = operation;\r\n    }\r\n\r\n    public static void initializeLeader(){\r\n        // start initial election\r\n        System.out.println(\"start FastBullyAlgorithm\");\r\n        Runnable procedure = new FastBullyAlgorithm(\"election\");\r\n        new Thread(procedure).start();\r\n    }\r\n\r\n\r\n    @Override\r\n    public void run() {\r\n        switch (operation){\r\n            case \"heartbeat\":\r\n                heartbeat();\r\n\r\n            case \"wait_answer\":                     //T2\r\n                try {\r\n                    Thread.sleep( t2 );\r\n\r\n                    if(!coordinatorStatus){\r\n                        if(answerStatus){\r\n                            //  2.4 If the answer messages are received within T2\r\n                            setUpNominator();\r\n\r\n                        }else{\r\n                            //  2.3 If no answer within T2\r\n                            setUpSelfAsLeader();\r\n                        }\r\n                    }\r\n\r\n                } catch (InterruptedException e) {\r\n                    System.out.println( \"INFO : Exception in wait_answer thread\" );\r\n                }\r\n                break;\r\n\r\n\r\n            case \"wait_view\":                     //T2\r\n                try {\r\n                    Thread.sleep( t2 );\r\n\r\n                    if(!coordinatorStatus){\r\n                        if(viewStatus){\r\n                            //  0.4 If the view messages are received within T2\r\n                            handleViews();\r\n\r\n                        }else{\r\n                            //  0.3 If no view messages within T2, Pi stops the procedure. // Pi is the coordinator\r\n                            setUpSelfAsLeader();\r\n                        }\r\n                    }\r\n\r\n                } catch (InterruptedException e) {\r\n                    System.out.println( \"INFO : Exception in wait_answer thread\" );\r\n                }\r\n                break;\r\n\r\n            case \"wait_coordination\":    //T3\r\n                try {\r\n                    Thread.sleep( t3 );\r\n\r\n                    //  2.6 If no coordinator message within T3\r\n                    if(nominationStatus && !coordinatorStatus){\r\n                        System.out.println( \"INFO : no coordinator message within T3\" );\r\n                        setUpNominator();\r\n                    }\r\n                } catch (InterruptedException e) {\r\n                    System.out.println( \"INFO : Exception in wait_coordination thread\" );\r\n                }\r\n                break;\r\n\r\n\r\n            case \"wait_coordination_nomination\":    //T4\r\n                try {\r\n                    Thread.sleep( t4 );\r\n\r\n                    //  3.3 If no coordinator message or nomination message within T4\r\n                    if( !nominationStatus && !coordinatorStatus){\r\n                        System.out.println( \"INFO : no coordinator message or nomination message -> restarts the procedure\" );\r\n\r\n                        //  3.3.1 Pj restarts the procedure\r\n                        electionStatus = false;\r\n                        answerStatus = false;\r\n\r\n                        Runnable procedure = new FastBullyAlgorithm(\"election\");\r\n                        new Thread(procedure).start();\r\n\r\n                    }\r\n\r\n                } catch (InterruptedException e) {\r\n                    System.out.println( \"INFO : Exception in wait_coordination_nomination thread\" );\r\n                }\r\n                break;\r\n\r\n            case \"election\":\r\n                try {\r\n                    answersMap.clear();\r\n                    sendElection();\r\n                } catch( Exception e ) {\r\n                    System.out.println( \"WARN : fail to send election request\" );\r\n                }\r\n                break;\r\n\r\n            case \"answer\":\r\n                try {\r\n                    sendAnswer();\r\n                } catch( Exception e ) {\r\n                    System.out.println( \"WARN : fail to send ok message\" );\r\n                }\r\n                break;\r\n\r\n            case \"nomination\":\r\n                try {\r\n                    sendNomination();\r\n                } catch( Exception e ) {\r\n                    System.out.println( \"WARN : fail to send coordination message\" );\r\n                }\r\n                break;\r\n\r\n            case \"coordination\":\r\n                try {\r\n                    sendCoordination();\r\n                } catch( Exception e ) {\r\n                    System.out.println( \"WARN : fail to send coordination message\" );\r\n                }\r\n                break;\r\n\r\n            case \"iamup\":\r\n                try {\r\n                    sendIamUp();\r\n                } catch( Exception e ) {\r\n                    System.out.println( \"WARN : fail to send IamUp message\" );\r\n                }\r\n                break;\r\n\r\n        }\r\n    }\r\n\r\n    public void heartbeat(){\r\n\r\n        while (true){\r\n            try {\r\n                Thread.sleep(10);\r\n\r\n                int leaderId = LeaderState.getInstance().getLeaderId();\r\n                int selfServerId = ServersState.getInstance().getSelfServerId();\r\n                boolean isNotLeader = selfServerId != leaderId;\r\n\r\n                if(coordinatorStatus && isNotLeader){\r\n                    Thread.sleep(t1);\r\n                    ConcurrentHashMap<Integer, Server> serversMap = ServersState.getInstance().getServersMap();\r\n                    Server destinationServer = serversMap.get(leaderId);\r\n\r\n                    JSONObject createHeartbeatReqObj = ServerResponse.createHeartbeatRequest(selfServerId);\r\n                    ServerMessage.sendToServer(createHeartbeatReqObj, destinationServer);\r\n                }\r\n\r\n            } catch (Exception e) {\r\n\r\n                coordinatorStatus = false;\r\n                System.out.println(\"WARN : Leader s\"+ LeaderState.getInstance().getLeaderId() + \" has failed\");\r\n\r\n                Runnable procedure = new FastBullyAlgorithm(\"election\");\r\n                new Thread(procedure).start();\r\n\r\n            }\r\n        }\r\n\r\n    }\r\n\r\n    public static void sendElection(){\r\n        System.out.println(\"INFO : start election\");\r\n\r\n        answerStatus = false;\r\n        viewStatus = false;\r\n        nominationStatus = false;\r\n        coordinatorStatus = false;\r\n\r\n        isLeader = false;\r\n        highestPriorityServerId = -1;\r\n\r\n        AtomicInteger failedRequestCount = new AtomicInteger();\r\n        int selfServerId = ServersState.getInstance().getSelfServerId();\r\n        ConcurrentHashMap<Integer, Server> serversMap = ServersState.getInstance().getServersMap();\r\n\r\n        // 2.1 Pi sends an election message to every process with higher priority number\r\n        serversMap.forEach((serverKey, destinationServer) -> {\r\n            if(serverKey > selfServerId){\r\n                try {\r\n                    JSONObject createElectionReqObj = ServerResponse.createElectionRequest(selfServerId);\r\n                    ServerMessage.sendToServer(createElectionReqObj, destinationServer);\r\n\r\n                }catch(Exception e){\r\n                    System.out.println(\"WARN : Server s\"+destinationServer.getserverId() + \" has failed, cannot send election request\");\r\n                    failedRequestCount.getAndIncrement();\r\n                }\r\n            }\r\n        });\r\n\r\n        //  2.2 Pi waits for answer messages for the interval T2\r\n        Runnable procedure = new FastBullyAlgorithm(\"wait_answer\");\r\n        new Thread(procedure).start();\r\n\r\n    }\r\n\r\n    public static void sendAnswer(){\r\n        try {\r\n            ConcurrentHashMap<Integer, Server> serversMap = ServersState.getInstance().getServersMap();\r\n            Server destinationServer = serversMap.get(sourceServerId);\r\n            int selfServerId = ServersState.getInstance().getSelfServerId();\r\n\r\n            JSONObject createElectionReqObj = ServerResponse.createAnswerRequest(selfServerId);\r\n            ServerMessage.sendToServer(createElectionReqObj, destinationServer);\r\n            System.out.println(\"INFO : Server s\"+ selfServerId +\" has sent answer message to s\" + sourceServerId);\r\n\r\n        }catch(Exception e){\r\n            System.out.println(\"INFO : Server s\"+ ServersState.getInstance().getSelfServerId() +\" has failed. answer message can not be sent to \" + sourceServerId);\r\n        }\r\n    }\r\n\r\n    public static void sendNomination(){\r\n        nominationStatus = true;\r\n        try {\r\n            ConcurrentHashMap<Integer, Server> serversMap = ServersState.getInstance().getServersMap();\r\n            Server nominatedServer = serversMap.get(highestPriorityServerId);\r\n            int selfServerId = ServersState.getInstance().getSelfServerId();\r\n\r\n            JSONObject createNominationReqObj = ServerResponse.createNominationRequest(selfServerId);\r\n            ServerMessage.sendToServer(createNominationReqObj, nominatedServer);\r\n            System.out.println(\"INFO : Server s\"+ selfServerId +\" has sent nomination message to s\" + highestPriorityServerId);\r\n\r\n        }catch(Exception e){\r\n            System.out.println(\"INFO : Server s\"+ ServersState.getInstance().getSelfServerId() +\" has failed to send nomination message\");\r\n        }\r\n\r\n        Runnable procedure = new FastBullyAlgorithm(\"wait_coordination\" );\r\n        new Thread( procedure ).start();\r\n    }\r\n\r\n    public static void sendCoordination(){\r\n\r\n        AtomicInteger failedRequestCount = new AtomicInteger();\r\n        int selfServerId = ServersState.getInstance().getSelfServerId();\r\n        ConcurrentHashMap<Integer, Server> serversMap = ServersState.getInstance().getServersMap();\r\n\r\n        //  2.3.1 Pi sends a coordinator message to other processes with lower priority number\r\n        //  3.4.1 Pj sends a coordinator message to all the processes with lower priority numbers\r\n        serversMap.forEach((serverKey, destinationServer) -> {\r\n            if(serverKey < selfServerId){\r\n                try {\r\n                    JSONObject createCoordinationReqObj = ServerResponse.createCoordinationRequest(selfServerId);\r\n                    ServerMessage.sendToServer(createCoordinationReqObj, destinationServer);\r\n                    System.out.println(\"INFO : Server s\"+ selfServerId +\" has sent coordinator message to s\" + destinationServer.getserverId());\r\n\r\n                }catch(Exception e){\r\n                    System.out.println(\"WARN : Server s\"+destinationServer.getserverId() + \" has failed, cannot send coordinator request\");\r\n                    failedRequestCount.getAndIncrement();\r\n                }\r\n            }\r\n        });\r\n\r\n//        failedRequestCount\r\n    }\r\n\r\n\r\n    public static void sendIamUp(){\r\n        System.out.println(\"INFO : Iam Up\");\r\n\r\n        answerStatus = false;\r\n        viewStatus = false;\r\n        nominationStatus = false;\r\n        coordinatorStatus = false;\r\n\r\n        isLeader = false;\r\n        highestPriorityServerId = -1;\r\n\r\n        AtomicInteger failedRequestCount = new AtomicInteger();\r\n        int selfServerId = ServersState.getInstance().getSelfServerId();\r\n        ConcurrentHashMap<Integer, Server> serversMap = ServersState.getInstance().getServersMap();\r\n\r\n        //  0.1 Pi sends an IamUp message to every process\r\n        serversMap.forEach((serverKey, destinationServer) -> {\r\n            if(serverKey != selfServerId){\r\n                try {\r\n                    JSONObject createIamUpReqObj = ServerResponse.createIamUpRequest(selfServerId);\r\n                    ServerMessage.sendToServer(createIamUpReqObj, destinationServer);\r\n\r\n                }catch(Exception e){\r\n                    System.out.println(\"WARN : Server s\"+ destinationServer.getserverId() + \" has failed, cannot send IamUp request\");\r\n                    failedRequestCount.getAndIncrement();\r\n                }\r\n            }\r\n        });\r\n\r\n        //  0.2 Pi waits for view messages for the interval T2\r\n        Runnable procedure = new FastBullyAlgorithm(\"wait_view\");\r\n        new Thread(procedure).start();\r\n\r\n    }\r\n\r\n\r\n    public static void sendView(int iamupServerId) {\r\n        try {\r\n            ConcurrentHashMap<Integer, Server> serversMap = ServersState.getInstance().getServersMap();\r\n            Set<Integer> localViews;\r\n            JSONArray viewsArray = new JSONArray();\r\n            Server destinationServer = serversMap.get(iamupServerId);\r\n\r\n            int selfServerId = ServersState.getInstance().getSelfServerId();\r\n            if (LeaderState.getInstance().isElectedLeader()){\r\n                localViews = LeaderState.getInstance().getActiveViews();\r\n            }else{\r\n                localViews = ServersState.getInstance().getViews();\r\n            }\r\n\r\n            viewsArray.addAll(localViews);\r\n\r\n            JSONObject createViewReqObj = ServerResponse.createViewRequest(selfServerId, viewsArray);\r\n            ServerMessage.sendToServer(createViewReqObj, destinationServer);\r\n            System.out.println(\"INFO : Server s\"+ selfServerId +\" has sent view message to s\" + iamupServerId);\r\n\r\n        }catch(Exception e){\r\n            System.out.println(\"INFO : Server s\"+ ServersState.getInstance().getSelfServerId() +\" has failed. view message can not be sent to \" + iamupServerId);\r\n        }\r\n    }\r\n\r\n    public static void handleViews(){\r\n\r\n        int selfServerId = ServersState.getInstance().getSelfServerId();\r\n        Set<Integer> localViews = ServersState.getInstance().getViews();\r\n\r\n        //  0.4.1 Pi compares its view with the received views\r\n        if(!localViews.equals(incomingViews)){\r\n\r\n            //  0.4.2 If the received view is different from the Piâ€™s view, Pi updates its view\r\n            ServersState.getInstance().resetViews();\r\n            ServersState.getInstance().setViewsList(incomingViews);\r\n        }\r\n\r\n        int maxView = Collections.max(ServersState.getInstance().getViews());\r\n\r\n        if(selfServerId == maxView){\r\n            //  0.4.3 If Pi is the highest priority numbered process\r\n            //  0.4.3.1 Pi sends a coordinator message to other processes with lower priority number\r\n            setUpSelfAsLeader();\r\n            //  0.4.3.2 Pi stops the procedure\r\n\r\n        }else{ //  0.4.4 Otherwise\r\n\r\n            //  0.4.4.1 Admit the highest priority numbered process as the coordinator\r\n            JSONObject requestObject = new JSONObject();\r\n            requestObject.put(\"identity\", maxView);\r\n            setUpCoordinatorAsLeader(requestObject);\r\n\r\n            //  0.4.4.2 Pi stops the election procedure\r\n        }\r\n    }\r\n\r\n    public static void setUpNominator(){\r\n\r\n        if(answersMap.isEmpty()){\r\n\r\n            //  2.6.2 If no process left to choose, Pi restarts the election procedure\r\n            if(!electionStatus){\r\n                electionStatus = true;\r\n                answerStatus = false;\r\n                nominationStatus = false;\r\n                coordinatorStatus = false;\r\n\r\n                Runnable procedure = new FastBullyAlgorithm(\"election\");\r\n                new Thread(procedure).start();\r\n            }\r\n\r\n\r\n        }else{\r\n\r\n            //  2.4.1 Pi determines the highest priority number of the answering processes\r\n            List<Integer> answerIds = new ArrayList<Integer>(answersMap.keySet());\r\n            System.out.println( \"INFO : nomination lists - \" + Arrays.toString(answerIds.toArray()) );\r\n\r\n            highestPriorityServerId = Collections.max(answerIds);\r\n            answersMap.remove(highestPriorityServerId);\r\n\r\n            System.out.println( \"INFO : Server s\" + highestPriorityServerId + \" is selected for nomination \" );\r\n\r\n            //  2.4.2 Pi sends a nomination message to this process\r\n            Runnable procedure_1 = new FastBullyAlgorithm(\"nomination\" );\r\n            new Thread( procedure_1 ).start();\r\n\r\n\r\n        }\r\n\r\n    }\r\n\r\n    public static void setUpSelfAsLeader(){\r\n\r\n        int selfServerId = ServersState.getInstance().getSelfServerId();\r\n        LeaderState.getInstance().setLeaderId( selfServerId );\r\n\r\n        LeaderState.getInstance().resetLeader(); // reset leader lists when newly elected\r\n\r\n        LeaderState.getInstance().setActiveViews(selfServerId);\r\n\r\n        isLeader = true;\r\n\r\n        //  2.3.2 Pi stops its election procedure\r\n        //  3.4.2 Pj stops its election procedure - coordinatorStatus->true in leader\r\n        electionStatus = false;\r\n        answerStatus = false;\r\n        viewStatus = false;\r\n        nominationStatus = false;\r\n        coordinatorStatus = true;\r\n\r\n        System.out.println( \"INFO : Server s\" + LeaderState.getInstance().getLeaderId() + \" is set as leader \" );\r\n\r\n\r\n        Runnable procedure = new FastBullyAlgorithm(\"coordination\" );\r\n        new Thread( procedure ).start();\r\n\r\n        JSONArray clientsArray = ServersState.getInstance().getClientList();\r\n        JSONArray chatRoomsArray = ServersState.getInstance().getChatRoomList();\r\n        try {\r\n            List<String> clients = new ArrayList<String>(Arrays.asList(clientsArray.toString()));\r\n            JSONArray chatroomsJSON = (JSONArray) new JSONParser().parse(chatRoomsArray.toString());\r\n\r\n            List<JSONObject> chatrooms = (List<JSONObject>) chatroomsJSON.stream().map(roomObject -> (JSONObject)roomObject).collect(Collectors.toList());\r\n\r\n            LeaderState.getInstance().addClients(clients);\r\n            LeaderState.getInstance().addChatRooms(chatrooms);\r\n\r\n        } catch (ParseException e) {\r\n            e.printStackTrace();\r\n        }\r\n\r\n    }\r\n\r\n\r\n    public static void handleRequest(JSONObject requestObject){\r\n        String request = (String) requestObject.get( \"request\" );\r\n\r\n        switch (request) {\r\n            case \"heartbeat\":\r\n                int senderId = Integer.parseInt(requestObject.get( \"identity\" ).toString());\r\n                System.out.println( \"INFO : Heartbeat received from s\" + senderId );\r\n                break;\r\n\r\n            case \"election\":    // 3 If a process Pj(i<j) receives an election message from Pi\r\n                \r\n                sourceServerId = Integer.parseInt(requestObject.get( \"identity\" ).toString());\r\n                System.out.println(\"INFO : Received election request from s\" + sourceServerId );\r\n\r\n                //  3.1 Pj sends an answer message to Pi\r\n                int selfServerId = ServersState.getInstance().getSelfServerId();\r\n                if( selfServerId > sourceServerId ) {\r\n                    Runnable procedure = new FastBullyAlgorithm( \"answer\" );\r\n                    new Thread( procedure ).start();\r\n                }\r\n\r\n                //  3.2 Pj waits for either a nomination or a coordinator message for the interval T4\r\n                Runnable procedure = new FastBullyAlgorithm(\"wait_coordination_nomination\");\r\n                new Thread(procedure).start();\r\n\r\n                break;\r\n\r\n            case \"answer\":\r\n\r\n                answerStatus = true;\r\n                int answerIdentity = Integer.parseInt(requestObject.get( \"identity\" ).toString());\r\n                System.out.println( \"INFO : Received answer from s\" + answerIdentity );\r\n\r\n                ConcurrentHashMap<Integer, Server> serversMap = ServersState.getInstance().getServersMap();\r\n                Server answerServer = serversMap.get(answerIdentity);\r\n                answersMap.put(answerIdentity, answerServer);\r\n\r\n                break;\r\n\r\n            case \"nomination\":\r\n\r\n                //  3.4 If a process Pj(i<j) receives the nomination message from Pi\r\n                setUpSelfAsLeader();\r\n                break;\r\n\r\n            case \"coordination\":\r\n                setUpCoordinatorAsLeader(requestObject);\r\n                break;\r\n\r\n            case \"iamup\":\r\n\r\n                int iamupServerId = Integer.parseInt(requestObject.get( \"identity\" ).toString());\r\n                System.out.println( \"INFO : Received IamUp from s\" + iamupServerId );\r\n                sendView(iamupServerId);\r\n                break;\r\n\r\n            case \"view\":\r\n\r\n                viewStatus = true;\r\n                int viewIdentity = Integer.parseInt(requestObject.get( \"identity\" ).toString());\r\n                System.out.println( \"INFO : Received view from s\" + viewIdentity );\r\n                updateIncomingView(requestObject);\r\n                break;\r\n        }\r\n    }\r\n\r\n    public static void setUpCoordinatorAsLeader(JSONObject requestObject){\r\n\r\n        int selfServerId = ServersState.getInstance().getSelfServerId();\r\n        int electedLeaderId = Integer.parseInt(requestObject.get( \"identity\" ).toString());\r\n\r\n        LeaderState.getInstance().setLeaderId( electedLeaderId );\r\n\r\n        //  2.3.2 Pi stops its election procedure\r\n        //  3.4.2 Pj stops its election procedure - coordinatorStatus->true in leader\r\n        electionStatus = false;\r\n        answerStatus = false;\r\n        viewStatus = false;\r\n        nominationStatus = false;\r\n        coordinatorStatus = true;\r\n\r\n\r\n        LeaderState.getInstance().resetLeader(); // reset leader lists when newly elected\r\n\r\n        ServersState.getInstance().resetViews();\r\n        ServersState.getInstance().setViews(electedLeaderId);\r\n\r\n        System.out.println( \"INFO : Receive coordination message & Server s\" + electedLeaderId + \" is Admit as leader \" );\r\n\r\n        // send local clients and chat rooms to leader\r\n        JSONArray clientsArray = ServersState.getInstance().getClientList();\r\n        JSONArray chatRoomsArray = ServersState.getInstance().getChatRoomList();\r\n\r\n        try {\r\n            JSONObject localUpdatesReqObj = ServerResponse.getLocalUpdatesRequest(selfServerId, clientsArray, chatRoomsArray);\r\n            ServerMessage.sendToLeader(localUpdatesReqObj);\r\n            System.out.println(\"INFO : Server s\"+ selfServerId +\" has sent local updates to s\" + electedLeaderId);\r\n\r\n        } catch (IOException e) {\r\n            System.out.println(\"WARN : Server s\"+ selfServerId +\" has fail to send local updates to s\" + electedLeaderId);\r\n        }\r\n\r\n    }\r\n\r\n    public static void updateIncomingView(JSONObject requestObject){\r\n\r\n        List<String> viewList = Arrays.asList(requestObject.get( \"view\" ).toString());\r\n        Set<Integer> viewSet = (Set<Integer>) viewList.stream().map(viewString -> Integer.parseInt(viewString)).collect(Collectors.toList());\r\n        incomingViews.addAll(viewSet);\r\n\r\n    }\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/app/election/FastBullyAlgorithm.java b/src/app/election/FastBullyAlgorithm.java
--- a/src/app/election/FastBullyAlgorithm.java	(revision 5e08476f9b1b94dfad87290fd0037ff8e8ae8d3d)
+++ b/src/app/election/FastBullyAlgorithm.java	(date 1647942272126)
@@ -1,5 +1,6 @@
 package app.election;
 
+import app.database.ServerDatabase;
 import app.leaderState.LeaderState;
 import app.response.ServerResponse;
 import app.server.Server;
@@ -445,6 +446,7 @@
         LeaderState.getInstance().resetLeader(); // reset leader lists when newly elected
 
         LeaderState.getInstance().setActiveViews(selfServerId);
+        ServerDatabase.saveView(LeaderState.getInstance().getActiveViews());
 
         isLeader = true;
 
@@ -566,6 +568,7 @@
 
         ServersState.getInstance().resetViews();
         ServersState.getInstance().setViews(electedLeaderId);
+        ServerDatabase.saveView(ServersState.getInstance().getViews());
 
         System.out.println( "INFO : Receive coordination message & Server s" + electedLeaderId + " is Admit as leader " );
 
Index: src/app/server/ServerHandlerThread.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package app.server;\r\n\r\nimport app.election.FastBullyAlgorithm;\r\nimport app.leaderState.LeaderState;\r\nimport app.response.ClientResponse;\r\nimport app.room.ChatRoom;\r\nimport org.json.simple.JSONArray;\r\nimport org.json.simple.JSONObject;\r\nimport org.json.simple.parser.JSONParser;\r\nimport org.json.simple.parser.ParseException;\r\n\r\nimport java.io.BufferedReader;\r\nimport java.io.IOException;\r\nimport java.io.InputStreamReader;\r\nimport java.io.PrintWriter;\r\nimport java.net.ServerSocket;\r\nimport java.net.Socket;\r\nimport java.util.ArrayList;\r\nimport java.util.Arrays;\r\nimport java.util.List;\r\nimport java.util.stream.Collectors;\r\n\r\npublic class ServerHandlerThread implements Runnable{\r\n\r\n    private final ServerSocket serverCoordinationSocket;\r\n\r\n    public ServerHandlerThread(ServerSocket serverCoordinationSocket){\r\n        this.serverCoordinationSocket = serverCoordinationSocket;\r\n    }\r\n\r\n    @Override\r\n    public void run() {\r\n        while (true){\r\n            try {\r\n                Socket serverSocket = serverCoordinationSocket.accept();\r\n                BufferedReader bufferedReader = new BufferedReader(new InputStreamReader(serverSocket.getInputStream()));\r\n                PrintWriter writer = new PrintWriter(serverSocket.getOutputStream(), true);\r\n                String msg = bufferedReader.readLine();\r\n                JSONObject server_obj = (JSONObject) new JSONParser().parse(msg);\r\n\r\n                // fast bully algorithm - respond to incoming request\r\n                if (server_obj.containsKey(\"request\")) {\r\n                    FastBullyAlgorithm.handleRequest(server_obj);\r\n\r\n                } else if (server_obj.containsKey(\"type\")) {\r\n\r\n                    // update leader state - if self server is the elected leader\r\n                    if (server_obj.get(\"type\").equals(\"leaderstateupdate\")) {\r\n                        if (LeaderState.getInstance().isElectedLeader()){\r\n                            updateLeaderState(server_obj);\r\n                        }\r\n\r\n                    }\r\n                }\r\n\r\n            } catch (IOException e) {\r\n                e.printStackTrace();\r\n            } catch (ParseException e) {\r\n                e.printStackTrace();\r\n            }\r\n        }\r\n    }\r\n\r\n    private void updateLeaderState(JSONObject server_obj) throws ParseException {\r\n\r\n        int senderId = Integer.parseInt(server_obj.get( \"identity\" ).toString());\r\n        LeaderState.getInstance().setActiveViews(senderId);\r\n\r\n        List<String> clients = new ArrayList<String>(Arrays.asList(server_obj.get( \"clients\" ).toString()));\r\n\r\n        JSONArray chatroomsJSON = (JSONArray) new JSONParser().parse(server_obj.get( \"chatrooms\" ).toString());\r\n        List<JSONObject> chatrooms = (List<JSONObject>) chatroomsJSON.stream().map(roomObject -> (JSONObject)roomObject).collect(Collectors.toList());\r\n\r\n        LeaderState.getInstance().addClients(clients);\r\n        LeaderState.getInstance().addChatRooms(chatrooms);\r\n\r\n        System.out.println(\"Sent local updated from s\" + senderId);\r\n        System.out.println( Arrays.toString(LeaderState.getInstance().getActiveClientsList().toArray()) );\r\n        System.out.println( Arrays.toString(LeaderState.getInstance().getActiveChatRooms().toArray()) );\r\n        System.out.println( Arrays.toString(LeaderState.getInstance().getActiveViews().toArray()) );\r\n    }\r\n\r\n\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/app/server/ServerHandlerThread.java b/src/app/server/ServerHandlerThread.java
--- a/src/app/server/ServerHandlerThread.java	(revision 5e08476f9b1b94dfad87290fd0037ff8e8ae8d3d)
+++ b/src/app/server/ServerHandlerThread.java	(date 1647942272439)
@@ -1,9 +1,11 @@
 package app.server;
 
+import app.database.ServerDatabase;
 import app.election.FastBullyAlgorithm;
 import app.leaderState.LeaderState;
 import app.response.ClientResponse;
 import app.room.ChatRoom;
+import app.serversState.ServersState;
 import org.json.simple.JSONArray;
 import org.json.simple.JSONObject;
 import org.json.simple.parser.JSONParser;
@@ -65,6 +67,7 @@
 
         int senderId = Integer.parseInt(server_obj.get( "identity" ).toString());
         LeaderState.getInstance().setActiveViews(senderId);
+        ServerDatabase.saveView(LeaderState.getInstance().getActiveViews());
 
         List<String> clients = new ArrayList<String>(Arrays.asList(server_obj.get( "clients" ).toString()));
 
Index: src/app/database/ServerDatabase.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/app/database/ServerDatabase.java b/src/app/database/ServerDatabase.java
new file mode 100644
--- /dev/null	(date 1647950416470)
+++ b/src/app/database/ServerDatabase.java	(date 1647950416470)
@@ -0,0 +1,41 @@
+package app.database;
+
+import app.serversState.ServersState;
+
+import java.sql.PreparedStatement;
+import java.sql.Connection;
+import java.sql.SQLException;
+import java.util.Set;
+
+public class ServerDatabase {
+
+    static Connection connection = DatabaseConnection.getInstance().getConnection();
+
+    public static void saveView(Set<Integer> view){
+//        String query = "update activeViews set view=? " + "where server_id = ?";
+//        String query = "insert into activeViews(server_id, " + "view) VALUES (?, ?)";
+        String server_id = String.valueOf(ServersState.getInstance().getSelfServerId());
+        String view_list = view.toString();
+
+        String query = "if exists(SELECT server_id from activeViews where server_id = ?)" +
+                        "BEGIN update activeViews set view=? where server_id = ? END " +
+                        "else" +
+                        "begin insert into activeViews(server_id,view) VALUES (?, ?)" + "end";
+
+        PreparedStatement ps = null;
+        try {
+            ps = connection.prepareStatement(query);
+            ps.setString(1, server_id);
+            ps.setString(2, view_list);
+            ps.setString(3, server_id);
+            ps.setString(4, server_id);
+            ps.setString(5, view_list);
+            ps.executeUpdate();
+
+        } catch (SQLException e) {
+            System.out.println("WARN: SQL Error - " + e.getMessage());
+        }
+
+    }
+
+}
Index: src/app/App.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>package app;\r\n\r\nimport app.election.FastBullyAlgorithm;\r\nimport app.serversState.ServersState;\r\n\r\n\r\npublic class App {\r\n\r\n    public static void main(String[] args) {\r\n\r\n        System.out.println(\"Input server : \" + args[0]);\r\n        ServersState.getInstance().initializeServer(args[0], args[1]);\r\n\r\n        FastBullyAlgorithm.initializeLeader();\r\n\r\n        Runnable heartbeat = new FastBullyAlgorithm(\"heartbeat\");\r\n        new Thread(heartbeat).start();\r\n    }\r\n}\r\n
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/app/App.java b/src/app/App.java
--- a/src/app/App.java	(revision 5e08476f9b1b94dfad87290fd0037ff8e8ae8d3d)
+++ b/src/app/App.java	(date 1647931239384)
@@ -1,5 +1,6 @@
 package app;
 
+import app.database.DatabaseConnection;
 import app.election.FastBullyAlgorithm;
 import app.serversState.ServersState;
 
@@ -10,6 +11,7 @@
 
         System.out.println("Input server : " + args[0]);
         ServersState.getInstance().initializeServer(args[0], args[1]);
+        DatabaseConnection.getInstance().initializeDatabaseConnection(args[0], args[1]);
 
         FastBullyAlgorithm.initializeLeader();
 
Index: src/module-info.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.BaseRevisionTextPatchEP
<+>module distributedChatApp {\r\n\trequires json.simple;\r\n}
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/module-info.java b/src/module-info.java
--- a/src/module-info.java	(revision 5e08476f9b1b94dfad87290fd0037ff8e8ae8d3d)
+++ b/src/module-info.java	(date 1647930677167)
@@ -1,3 +1,4 @@
 module distributedChatApp {
 	requires json.simple;
+    requires java.sql;
 }
\ No newline at end of file
Index: src/app/database/DatabaseConnection.java
IDEA additional info:
Subsystem: com.intellij.openapi.diff.impl.patch.CharsetEP
<+>UTF-8
===================================================================
diff --git a/src/app/database/DatabaseConnection.java b/src/app/database/DatabaseConnection.java
new file mode 100644
--- /dev/null	(date 1647937616123)
+++ b/src/app/database/DatabaseConnection.java	(date 1647937616123)
@@ -0,0 +1,62 @@
+package app.database;
+
+import app.serversState.ServersState;
+
+import java.sql.Connection;
+import java.sql.DriverManager;
+
+import java.io.File;
+import java.util.Scanner;
+
+public class DatabaseConnection {
+
+    private static DatabaseConnection dbConnectionInstance;
+    private static Connection connection = null;
+    
+    private DatabaseConnection() {
+    }
+
+    public void initializeDatabaseConnection(String serverId, String server_config_path) {
+        String db_config_path = server_config_path.replace("server_config", "database_config");
+
+        try {
+            File file = new File(db_config_path);
+            Scanner myReader = new Scanner(file);
+            while (myReader.hasNextLine()) {
+                String data = myReader.nextLine();
+                String[] db_config = data.split(" ");
+                
+                if (db_config[0].equals(serverId)) {
+                    String url = db_config[1];
+                    String user = db_config[2];
+                    String password = "";
+
+                    Class.forName("com.mysql.cj.jdbc.Driver");
+                    connection = DriverManager.getConnection(url, user, password);
+                    System.out.println("Info: DB Connect ");
+                }
+
+            }
+
+        } catch (Exception e) {
+            System.out.println("An error occurred - " + e.getMessage());
+        }
+    }
+
+    public static DatabaseConnection getInstance() {
+        if (dbConnectionInstance == null) {
+            synchronized (DatabaseConnection.class) {
+                if (dbConnectionInstance == null) {
+                    dbConnectionInstance = new DatabaseConnection();
+                }
+            }
+        }
+        return dbConnectionInstance;
+    }
+
+    public Connection getConnection() {
+        return connection;
+    }
+
+    
+}
